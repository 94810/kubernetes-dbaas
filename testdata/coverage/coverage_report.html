
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bedag/kubernetes-dbaas/apis/database/v1/database_types.go (100.0%)</option>
				
				<option value="file1">github.com/bedag/kubernetes-dbaas/apis/database/v1/database_webhook.go (10.0%)</option>
				
				<option value="file2">github.com/bedag/kubernetes-dbaas/apis/database/v1/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file3">github.com/bedag/kubernetes-dbaas/controllers/database/database_controller.go (71.3%)</option>
				
				<option value="file4">github.com/bedag/kubernetes-dbaas/pkg/database/dbms.go (42.7%)</option>
				
				<option value="file5">github.com/bedag/kubernetes-dbaas/pkg/database/dsn.go (72.7%)</option>
				
				<option value="file6">github.com/bedag/kubernetes-dbaas/pkg/database/mysql.go (53.2%)</option>
				
				<option value="file7">github.com/bedag/kubernetes-dbaas/pkg/database/psql.go (51.1%)</option>
				
				<option value="file8">github.com/bedag/kubernetes-dbaas/pkg/database/rate_limiter.go (53.8%)</option>
				
				<option value="file9">github.com/bedag/kubernetes-dbaas/pkg/database/sqlserver.go (43.2%)</option>
				
				<option value="file10">github.com/bedag/kubernetes-dbaas/pkg/database/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file11">github.com/bedag/kubernetes-dbaas/pkg/pool/pool.go (65.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// DatabaseSpec defines the desired state of Database.
type DatabaseSpec struct {
        // Endpoint associates this resource with a particular endpoint (must be already configured on the operator side)
        Endpoint string `json:"endpoint,omitempty"`
        // Params is a map containing parameters to be mapped to the database instance
        Params map[string]string `json:"params,omitempty"`
}

// DatabaseStatus defines the observed state of Database.
type DatabaseStatus struct {
        // Conditions represent the latest available observations of an object's state
        Conditions []metav1.Condition `json:"conditions"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:shortName=db
// +kubebuilder:printcolumn:JSONPath=.status.conditions[*].status,description="Ready status of resource",name="Ready",type=string
// +kubebuilder:printcolumn:JSONPath=.spec.endpoint,description="The endpoint where the resource is supposed to be provisioned",name="Endpoint",type=string
// Database is the Schema for the database API
type Database struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   DatabaseSpec   `json:"spec,omitempty"`
        Status DatabaseStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// DatabaseList contains a list of Database
type DatabaseList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Database `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;Database{}, &amp;DatabaseList{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "reflect"
        ctrl "sigs.k8s.io/controller-runtime"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// log is for logging in this package.
var databaselog = logf.Log.WithName("database-resource-webhook")

func (r *Database) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(r).
                Complete()
}</span>

//+kubebuilder:webhook:path=/mutate-database-dbaas-bedag-ch-v1-database,mutating=true,failurePolicy=fail,sideEffects=None,groups=database.dbaas.bedag.ch,resources=databases,verbs=create;update,versions=v1,name=mdatabase.kb.io,admissionReviewVersions={v1,v1beta1}

var _ webhook.Defaulter = &amp;Database{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Database) Default() {<span class="cov0" title="0">
        //databaselog.Info("default", "name", r.Name)

        // TODO(user): fill in with defaulting logic
}</span>

// TODO(user): change verbs to "verbs=create;update;delete" if you want to enable deletion validation.
//+kubebuilder:webhook:path=/validate-database-dbaas-bedag-ch-v1-database,mutating=false,failurePolicy=fail,sideEffects=None,groups=database.dbaas.bedag.ch,resources=databases,verbs=create;update,versions=v1,name=vdatabase.kb.io,admissionReviewVersions={v1,v1beta1}

var _ webhook.Validator = &amp;Database{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Database) ValidateCreate() error <span class="cov0" title="0">{
        return nil
}</span>

// ValidateUpdate disables any update to the 'spec' field of Database resources.
func (r *Database) ValidateUpdate(old runtime.Object) error <span class="cov0" title="0">{
        databaselog.Info("validate update", "name", r.Name)
        var allErrs field.ErrorList

        rOld := old.(*Database)

        if !reflect.DeepEqual(r.Spec, rOld.Spec) </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("spec"), r.Spec, "update operations not allowed, please explicitly "+
                        "delete the resource in order to recreate it."))

                return apierrors.NewInvalid(schema.GroupKind{Group: "database.dbaas.bedag.ch", Kind: "Database"},
                        "database", allErrs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Database) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// +build !ignore_autogenerated

/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Database) DeepCopyInto(out *Database) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Database.
func (in *Database) DeepCopy() *Database <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Database)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Database) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseList) DeepCopyInto(out *DatabaseList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]Database, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseList.
func (in *DatabaseList) DeepCopy() *DatabaseList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DatabaseList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DatabaseList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseSpec) DeepCopyInto(out *DatabaseSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Params != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Params, &amp;out.Params
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseSpec.
func (in *DatabaseSpec) DeepCopy() *DatabaseSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DatabaseSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseStatus) DeepCopyInto(out *DatabaseStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]metav1.Condition, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseStatus.
func (in *DatabaseStatus) DeepCopy() *DatabaseStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DatabaseStatus)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/bedag/kubernetes-dbaas/internal/logging"
        "github.com/bedag/kubernetes-dbaas/pkg/database"
        "github.com/bedag/kubernetes-dbaas/pkg/pool"
        . "github.com/bedag/kubernetes-dbaas/pkg/typeutil"
        "github.com/go-logr/logr"
        corev1 "k8s.io/api/core/v1"
        k8sError "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
        "k8s.io/client-go/tools/record"
        "reflect"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "strings"

        databasev1 "github.com/bedag/kubernetes-dbaas/apis/database/v1"
        databaseclassv1 "github.com/bedag/kubernetes-dbaas/apis/databaseclass/v1"
)

const (
        InfoLevel  = logging.InfoLevel
        DebugLevel = logging.ZapDebugLevel
        TraceLevel = logging.ZapTraceLevel

        DatabaseControllerName = "database-controller"
        DatabaseClass          = "databaseclass"
        EndpointName           = "endpoint-name"
        SecretName             = "secret-name"
        databaseFinalizer      = "finalizer.database.bedag.ch"
        rotateAnnotationKey    = "dbaas.bedag.ch/rotate"
)

type ReconcileError struct {
        Reason         string
        Message        string
        Err            error
        AdditionalInfo []interface{}
}

// DatabaseReconciler reconciles a Database object
type DatabaseReconciler struct {
        client.Client
        Log           logr.Logger
        Scheme        *runtime.Scheme
        EventRecorder record.EventRecorder
        DbmsList      database.DbmsList
        Pool          pool.Pool
}

var logger logr.Logger

// +kubebuilder:rbac:groups=database.dbaas.bedag.ch,resources=databases,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=database.dbaas.bedag.ch,resources=databases/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=database.dbaas.bedag.ch,resources=databases/finalizers,verbs=update
// +kubebuilder:rbac:groups=databaseclass.dbaas.bedag.ch,resources=databaseclasses,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch;create;update;delete
// SetupWithManager creates the controller responsible for Database resources by means of a ctrl.Manager.
func (r *DatabaseReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov1" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                Named(DatabaseControllerName).
                For(&amp;databasev1.Database{}).
                Owns(&amp;corev1.Secret{}).
                WithEventFilter(r.triggerReconciler()).
                Complete(r)
}</span>

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="31">{
        logger = r.Log.WithValues("database", req.NamespacedName)
        logger.V(TraceLevel).Info("Reconcile called")

        obj := &amp;databasev1.Database{}
        err := r.Get(ctx, req.NamespacedName, obj)
        if err != nil </span><span class="cov5" title="8">{
                if k8sError.IsNotFound(err) </span><span class="cov5" title="8">{
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        logger.V(TraceLevel).Info(MsgDbDeleted)
                        return reconcile.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov0" title="0">r.handleReconcileError(obj, ReconcileError{
                        Reason:  RsnDbGetFail,
                        Message: MsgDbGetFail,
                        Err:     err,
                })
                return reconcile.Result{Requeue: true}, nil</span>
        }

        // Set reason to unknown to indicate the resource was correctly received by a controller but no action was resolved yet
        // Update condition field
        <span class="cov7" title="23">if meta.FindStatusCondition(obj.Status.Conditions, TypeReady) == nil </span><span class="cov3" title="4">{
                logger.V(TraceLevel).Info("Updating ConditionStatus")
                if err = r.updateReadyCondition(obj, metav1.ConditionUnknown, RsnDbOpQueueSucc, MsgDbOpQueueSucc); err != nil </span><span class="cov0" title="0">{
                        r.handleReconcileError(obj, ReconcileError{
                                Reason:  RsnReadyCondUpdateFail,
                                Message: MsgReadyCondUpdateFail,
                                Err:     err,
                        })

                        return ctrl.Result{Requeue: true}, nil
                }</span>
        }

        // Check if the Database instance is marked to be deleted, which is
        // indicated by the deletion timestamp being set.
        <span class="cov7" title="23">if obj.GetDeletionTimestamp() != nil </span><span class="cov3" title="4">{
                if contains(obj.GetFinalizers(), databaseFinalizer) </span><span class="cov3" title="4">{
                        // Run finalization logic for DatabaseFinalizer. If the
                        // finalization logic fails, don't remove the finalizer so
                        // that we can retry during the next reconciliation.
                        logger.V(TraceLevel).Info("Finalizing database resource")
                        if err := r.deleteDb(obj); err.IsNotEmpty() </span><span class="cov0" title="0">{
                                r.handleReconcileError(obj, err)
                                return reconcile.Result{Requeue: true}, nil
                        }</span>

                        // Remove databaseFinalizer. Once all finalizers have been
                        // removed, the object will be deleted.
                        <span class="cov3" title="4">logger.V(TraceLevel).Info("Removing finalizer")
                        controllerutil.RemoveFinalizer(obj, databaseFinalizer)
                        if err := r.Update(ctx, obj); err != nil </span><span class="cov0" title="0">{
                                if !shouldIgnoreUpdateErr(err) </span><span class="cov0" title="0">{
                                        r.handleReconcileError(obj, ReconcileError{
                                                Reason:         RsnDbUpdateFail,
                                                Message:        MsgDbUpdateFail,
                                                Err:            err,
                                                AdditionalInfo: StringsToInterfaceSlice("finalizer", databaseFinalizer),
                                        })
                                }</span>

                                <span class="cov0" title="0">return reconcile.Result{Requeue: true}, nil</span>
                        }
                }
                <span class="cov3" title="4">return reconcile.Result{}, nil</span>
        }

        // If Database is ready
        <span class="cov7" title="19">if meta.IsStatusConditionTrue(obj.Status.Conditions, TypeReady) </span><span class="cov6" title="14">{
                logger.V(TraceLevel).Info("Database resource is in Ready state")
                // Check if Database credentials should be rotated
                shouldRotate, err := r.shouldRotate(obj)
                if err.IsNotEmpty() </span><span class="cov0" title="0">{
                        r.handleReconcileError(obj, err)
                        return ctrl.Result{Requeue: true}, nil
                }</span>
                <span class="cov6" title="14">if shouldRotate </span><span class="cov3" title="4">{
                        // Update Ready condition to false, Database credentials must be rotated
                        if err := r.updateReadyCondition(obj, metav1.ConditionFalse, RsnDbRotateInProg, MsgDbRotateInProg); err != nil </span><span class="cov0" title="0">{
                                r.handleReadyConditionError(obj, err)
                                return ctrl.Result{Requeue: true}, nil
                        }</span>
                        <span class="cov3" title="4">if err := r.rotate(obj); err.IsNotEmpty() </span><span class="cov0" title="0">{
                                r.handleReconcileError(obj, err)
                                return ctrl.Result{Requeue: true}, nil
                        }</span>
                        // Update Ready condition to true
                        <span class="cov3" title="4">if err := r.updateReadyCondition(obj, metav1.ConditionTrue, RsnDbRotateSucc, MsgDbRotateSucc); err != nil </span><span class="cov0" title="0">{
                                r.handleReadyConditionError(obj, err)
                                return ctrl.Result{Requeue: true}, nil
                        }</span>
                        <span class="cov3" title="4">r.logInfoEvent(obj, RsnDbRotateSucc, MsgDbRotateSucc)</span>
                } else<span class="cov5" title="10"> {
                        // Database is ready and credentials shouldn't be rotated, nothing else to do
                        logger.V(TraceLevel).Info("Credentials should not be rotated, nothing left to do")
                        return ctrl.Result{}, nil
                }</span>
        } else<span class="cov4" title="5"> {
                // Create
                if err := r.createDb(obj); err.IsNotEmpty() </span><span class="cov1" title="1">{
                        r.handleReconcileError(obj, err)
                        return ctrl.Result{Requeue: true}, nil
                }</span>

                <span class="cov3" title="4">logger.V(TraceLevel).Info("Updating ConditionStatus")
                if err := r.updateReadyCondition(obj, metav1.ConditionTrue, RsnDbCreateSucc, MsgDbCreateSucc); err != nil </span><span class="cov0" title="0">{
                        r.handleReadyConditionError(obj, err)
                        return ctrl.Result{Requeue: true}, nil
                }</span>
        }

        // If finalizer is not present, add finalizer to resource
        <span class="cov5" title="8">if !contains(obj.GetFinalizers(), databaseFinalizer) </span><span class="cov3" title="4">{
                logger.V(TraceLevel).Info("Adding finalizer")
                if err := r.addFinalizer(obj); err != nil </span><span class="cov0" title="0">{
                        r.handleReconcileError(obj, ReconcileError{
                                Reason:         RsnDbUpdateFail,
                                Message:        MsgDbUpdateFail,
                                Err:            err,
                                AdditionalInfo: StringsToInterfaceSlice("finalizer", databaseFinalizer),
                        })
                        return ctrl.Result{Requeue: true}, nil
                }</span>
        }

        <span class="cov5" title="8">logger.V(TraceLevel).Info("Reached end of reconcile")
        return ctrl.Result{}, nil</span>
}

// addFinalizer adds a finalizer to a Database resource.
func (r *DatabaseReconciler) addFinalizer(obj *databasev1.Database) error <span class="cov3" title="4">{
        controllerutil.AddFinalizer(obj, databaseFinalizer)
        return r.Update(context.Background(), obj)
}</span>

// createDb creates a new Database instance on the external provisioner based on the Database data.
func (r *DatabaseReconciler) createDb(obj *databasev1.Database) ReconcileError <span class="cov4" title="5">{
        r.logInfoEvent(obj, RsnDbCreateInProg, MsgDbCreateInProg)

        dbClass, err := r.getDbmsClassFromDb(obj)
        if err.IsNotEmpty() </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">loggingKv := StringsToInterfaceSlice(DatabaseClass, dbClass.Name, database.OperationsConfigKey, database.CreateMapKey)

        // Render operation
        createOpTemplate, exists := dbClass.Spec.Operations[database.CreateMapKey]
        if !exists </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnOpNotSupported,
                        Message:        MsgOpNotSupported,
                        Err:            nil,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov4" title="5">opValues, err := newOpValuesFromResource(obj)
        if err.IsNotEmpty() </span><span class="cov0" title="0">{
                return err.With(loggingKv)
        }</span>
        <span class="cov4" title="5">createOp, simpleErr := createOpTemplate.RenderOperation(opValues)
        if simpleErr != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnOpRenderFail,
                        Message:        MsgOpRenderFail,
                        Err:            simpleErr,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov4" title="5">loggingKv = append(loggingKv, EndpointName, obj.Spec.Endpoint)

        // Execute operation on DBMS
        // Check preconditions
        var conn database.Driver
        if conn, err = r.getDbmsConnectionByEndpointName(obj.Spec.Endpoint); err.IsNotEmpty() </span><span class="cov0" title="0">{
                return err.With(loggingKv)
        }</span>
        <span class="cov4" title="5">output := conn.CreateDb(createOp)
        if output.Err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnDbCreateFail,
                        Message:        MsgDbCreateFail,
                        Err:            output.Err,
                        AdditionalInfo: loggingKv,
                }
        }</span>

        // Log success
        <span class="cov4" title="5">r.logInfoEvent(obj, RsnDbCreateSucc, MsgDbCreateSucc)
        logger.V(TraceLevel).Info(fmt.Sprint(dbClass.Spec.SecretFormat))
        logger.V(TraceLevel).Info(fmt.Sprint(output))
        // Create Secret
        err = r.createSecret(obj, dbClass.Spec.SecretFormat, output)
        if err.IsNotEmpty() </span><span class="cov1" title="1">{
                return err.With(loggingKv)
        }</span>

        <span class="cov3" title="4">return ReconcileError{}</span>
}

// deleteDb deletes the database instance on the external provisioner.
func (r *DatabaseReconciler) deleteDb(obj *databasev1.Database) ReconcileError <span class="cov3" title="4">{
        r.logInfoEvent(obj, RsnDbDeleteInProg, MsgDbDeleteInProg)

        dbClass, reconcileErr := r.getDbmsClassFromDb(obj)
        if reconcileErr.IsNotEmpty() </span><span class="cov0" title="0">{
                return reconcileErr
        }</span>
        <span class="cov3" title="4">loggingKv := StringsToInterfaceSlice(DatabaseClass, dbClass.Name, database.OperationsConfigKey, database.DeleteMapKey)

        // Render operation
        deleteOpTemplate, exists := dbClass.Spec.Operations[database.DeleteMapKey]
        if !exists </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnOpNotSupported,
                        Message:        MsgOpNotSupported,
                        Err:            nil,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">opValues, reconcileErr := newOpValuesFromResource(obj)
        if reconcileErr.IsNotEmpty() </span><span class="cov0" title="0">{
                return reconcileErr.With(loggingKv)
        }</span>
        <span class="cov3" title="4">deleteOp, err := deleteOpTemplate.RenderOperation(opValues)
        if err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnOpRenderFail,
                        Message:        MsgOpRenderFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">loggingKv = append(loggingKv, EndpointName, obj.Spec.Endpoint)

        // Execute operation on DBMS
        // Check preconditions
        var conn database.Driver
        if conn, reconcileErr = r.getDbmsConnectionByEndpointName(obj.Spec.Endpoint); reconcileErr.IsNotEmpty() </span><span class="cov0" title="0">{
                return reconcileErr.With(loggingKv)
        }</span>
        <span class="cov3" title="4">conn = r.Pool.Get(obj.Spec.Endpoint)
        if conn == nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnDbmsEndpointNotFound,
                        Message:        MsgDbmsEndpointNotFound,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">output := conn.DeleteDb(deleteOp)
        if output.Err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnDbDeleteFail,
                        Message:        MsgDbDeleteFail,
                        Err:            output.Err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">return ReconcileError{}</span>
}

// rotate rotates the database credentials on the external provisioner.
func (r *DatabaseReconciler) rotate(obj *databasev1.Database) ReconcileError <span class="cov3" title="4">{
        r.logInfoEvent(obj, RsnDbRotateInProg, MsgDbRotateInProg)

        dbClass, reconcileErr := r.getDbmsClassFromDb(obj)
        if reconcileErr.IsNotEmpty() </span><span class="cov0" title="0">{
                return reconcileErr
        }</span>
        <span class="cov3" title="4">loggingKv := StringsToInterfaceSlice(DatabaseClass, dbClass.Name, database.OperationsConfigKey, database.RotateMapKey)
        rotateOpTemplate, exists := dbClass.Spec.Operations[database.RotateMapKey]
        if !exists </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnOpNotSupported,
                        Message:        MsgOpNotSupported,
                        Err:            nil,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">opValues, reconcileErr := newOpValuesFromResource(obj)
        if reconcileErr.IsNotEmpty() </span><span class="cov0" title="0">{
                return reconcileErr.With(loggingKv)
        }</span>
        <span class="cov3" title="4">rotateOp, err := rotateOpTemplate.RenderOperation(opValues)
        if err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnOpRenderFail,
                        Message:        MsgOpRenderFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">loggingKv = append(loggingKv, EndpointName, obj.Spec.Endpoint)

        // Execute operation on DBMS
        // Check preconditions
        var conn database.Driver
        if conn, reconcileErr = r.getDbmsConnectionByEndpointName(obj.Spec.Endpoint); reconcileErr.IsNotEmpty() </span><span class="cov0" title="0">{
                return reconcileErr.With(loggingKv)
        }</span>
        <span class="cov3" title="4">conn = r.Pool.Get(obj.Spec.Endpoint)
        if conn == nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnDbmsEndpointNotFound,
                        Message:        MsgDbmsEndpointNotFound,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="4">output := conn.Rotate(rotateOp)
        if output.Err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnDbRotateFail,
                        Message:        MsgDbRotateFail,
                        Err:            output.Err,
                        AdditionalInfo: loggingKv,
                }
        }</span>

        <span class="cov3" title="4">if isSecretPresent, err := r.isSecretPresent(obj); isSecretPresent </span><span class="cov3" title="3">{
                if err.IsNotEmpty() </span><span class="cov0" title="0">{
                        return err.With(loggingKv)
                }</span>
                // Secret is already present, update it
                <span class="cov3" title="3">err = r.updateSecret(obj, dbClass.Spec.SecretFormat, output)
                if err.IsNotEmpty() </span><span class="cov0" title="0">{
                        return err.With(loggingKv)
                }</span>
        } else<span class="cov1" title="1"> {
                // Secret is not present, create it
                err = r.createSecret(obj, dbClass.Spec.SecretFormat, output)
                if err.IsNotEmpty() </span><span class="cov0" title="0">{
                        return err.With(loggingKv)
                }</span>
        }

        // Remove annotation if present
        <span class="cov3" title="4">if isRotateAnnotationTrue(obj) </span><span class="cov3" title="3">{
                logger.V(TraceLevel).Info("Removing rotate annotation")
                delete(obj.GetAnnotations(), rotateAnnotationKey)
                err := r.Client.Update(context.Background(), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return ReconcileError{
                                Reason:         RsnDbUpdateFail,
                                Message:        MsgDbUpdateFail,
                                Err:            err,
                                AdditionalInfo: loggingKv,
                        }
                }</span>
        }

        <span class="cov3" title="4">return ReconcileError{}</span>
}

func (r *DatabaseReconciler) getDbmsClassFromDb(obj *databasev1.Database) (databaseclassv1.DatabaseClass, ReconcileError) <span class="cov6" title="13">{
        // Get DatabaseClass resource from api server
        dbClassName := r.DbmsList.GetDatabaseClassNameByEndpointName(obj.Spec.Endpoint)
        if dbClassName == "" </span><span class="cov0" title="0">{
                return databaseclassv1.DatabaseClass{}, ReconcileError{
                        Reason:         RsnDbcConfigGetFail,
                        Message:        MsgDbcConfigGetFail,
                        Err:            fmt.Errorf("could not find any DatabaseClass for endpoint '%s'", obj.Spec.Endpoint),
                        AdditionalInfo: StringsToInterfaceSlice(EndpointName, obj.Spec.Endpoint),
                }
        }</span>

        <span class="cov6" title="13">dbClass := databaseclassv1.DatabaseClass{}
        err := r.Client.Get(context.Background(), client.ObjectKey{Namespace: "", Name: dbClassName}, &amp;dbClass)
        if err != nil </span><span class="cov0" title="0">{
                return databaseclassv1.DatabaseClass{}, ReconcileError{
                        Reason:         RsnDbcGetFail,
                        Message:        MsgDbcGetFail,
                        Err:            err,
                        AdditionalInfo: StringsToInterfaceSlice(DatabaseClass, dbClassName),
                }
        }</span>
        <span class="cov6" title="13">return dbClass, ReconcileError{}</span>
}

func (r *DatabaseReconciler) getDbmsConnectionByEndpointName(endpointName string) (database.Driver, ReconcileError) <span class="cov6" title="13">{
        // Check if the endpoint is currently stored in the connection pool
        conn := r.Pool.Get(endpointName)
        if conn == nil </span><span class="cov0" title="0">{
                return nil, ReconcileError{
                        Reason:  RsnDbmsEndpointNotFound,
                        Message: MsgDbmsEndpointNotFound,
                        Err:     nil,
                }
        }</span>
        // Make a first check to acknowledge whether the connection looks alive
        <span class="cov6" title="13">if simpleErr := conn.Ping(); simpleErr != nil </span><span class="cov0" title="0">{
                return nil, ReconcileError{
                        Reason:  RsnDbmsConnFail,
                        Message: MsgDbmsConnFail,
                        Err:     simpleErr,
                }
        }</span>
        <span class="cov6" title="13">return conn, ReconcileError{}</span>
}

// handleReconcileError sets the obj Conditions type Ready to false and sets the relative fields error and message,
// it records a Warning event with reason and message for the given obj and logs err (if present) and message to the
// global logger.
// It ignores optimistic locking error, see shouldIgnoreUpdateErr.
func (r *DatabaseReconciler) handleReconcileError(obj *databasev1.Database, err ReconcileError) <span class="cov1" title="1">{
        if shouldIgnoreUpdateErr(err.Err) </span><span class="cov0" title="0">{
                logger.V(TraceLevel).Info(err.Err.Error())
                return
        }</span>
        <span class="cov1" title="1">keyAndValuesLen := len(err.AdditionalInfo)
        if keyAndValuesLen%2 != 0 </span><span class="cov0" title="0">{
                logger.Error(nil, "odd number of keyAndValues provided!", err.AdditionalInfo...)
                // Set length to 0 so additional values are ignored
                keyAndValuesLen = 0
        }</span>
        <span class="cov1" title="1">if keyAndValuesLen &gt; 0 </span><span class="cov1" title="1">{
                r.EventRecorder.Event(obj, Warning, err.Reason, formatEventMessage(err.Message, err.AdditionalInfo...))
                logger.Error(err.Err, err.Message, err.AdditionalInfo...)
        }</span> else<span class="cov0" title="0"> {
                r.EventRecorder.Event(obj, Warning, err.Reason, err.Message)
                logger.Error(err.Err, err.Message)
        }</span>
        <span class="cov1" title="1">if updateErr := r.updateReadyCondition(obj, metav1.ConditionFalse, err.Reason, err.Message); updateErr != nil </span><span class="cov1" title="1">{
                logger.Error(err.Err, MsgDbUpdateFail)
        }</span>
}

// handleReadyConditionError records an event of type Warning to obj using RsnReadyCondUpdateFail, MsgReadyCondUpdateFail
// and additionalInfo. additionalInfo is formatted as JSON and attached to the event message.
// An error log using message and additionalInfo is written using the global logger.
// It ignores optimistic locking error, see shouldIgnoreUpdateErr.
func (r *DatabaseReconciler) handleReadyConditionError(obj *databasev1.Database, err error, additionalInfo ...interface{}) <span class="cov0" title="0">{
        if shouldIgnoreUpdateErr(err) </span><span class="cov0" title="0">{
                logger.V(TraceLevel).Info(err.Error())
                return
        }</span>
        // In the grim situation where the Ready condition cannot be updated, dump everything to the resource event stream
        // and logger
        <span class="cov0" title="0">eventMessage := formatEventMessage(MsgReadyCondUpdateFail, additionalInfo...)
        r.EventRecorder.Event(obj, Warning, RsnReadyCondUpdateFail, eventMessage)
        logger.Error(err, MsgReadyCondUpdateFail, additionalInfo...)</span>
}

// logInfoEvent records an event of type Normal to obj using reason, message and additionalInfo. additionalInfo is formatted
// as JSON and attached to the event message. An info log using message and additionalInfo is written using the global logger
func (r *DatabaseReconciler) logInfoEvent(obj *databasev1.Database, reason, message string, additionalInfo ...interface{}) <span class="cov8" title="30">{
        eventMessage := formatEventMessage(message, additionalInfo...)
        r.EventRecorder.Event(obj, Normal, reason, eventMessage)
        logger.Info(message, additionalInfo...)
}</span>

// createSecret creates a new K8s secret owned by owner with the data contained in output and dsn.
func (r *DatabaseReconciler) createSecret(owner *databasev1.Database, secretFormat database.SecretFormat, output database.OpOutput) ReconcileError <span class="cov4" title="6">{
        logger.V(DebugLevel).Info("Creating secret for database resource")

        // Init vars
        secretName := FormatSecretName(owner)
        loggingKv := StringsToInterfaceSlice("secret", secretName)
        secretData, err := secretFormat.RenderSecretFormat(output)
        if err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnSecretRenderFail,
                        Message:        MsgSecretRenderFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov4" title="6">var ownerRefs []metav1.OwnerReference
        ownerRefs = append(ownerRefs, metav1.OwnerReference{
                APIVersion: owner.APIVersion,
                Kind:       owner.Kind,
                Name:       owner.Name,
                UID:        owner.UID,
                Controller: &amp;[]bool{true}[0], // sets this controller as owner
        })
        secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            secretName,
                        Namespace:       owner.Namespace,
                        OwnerReferences: ownerRefs,
                },
                StringData: secretData,
        }
        key := client.ObjectKey{
                Namespace: owner.Namespace,
                Name:      secretName,
        }
        oldSecret := corev1.Secret{}
        // Get old Secret if present
        err = r.Client.Get(context.Background(), key, &amp;oldSecret)
        if err != nil </span><span class="cov4" title="5">{
                // If Secret was not found, it must be created
                if k8sError.IsNotFound(err) </span><span class="cov4" title="5">{
                        // Create new Secret
                        if err := r.Client.Create(context.Background(), secret); err != nil </span><span class="cov0" title="0">{
                                return ReconcileError{
                                        Reason:         MsgSecretCreateFail,
                                        Message:        MsgSecretCreateFail,
                                        Err:            err,
                                        AdditionalInfo: loggingKv,
                                }
                        }</span>
                        <span class="cov4" title="5">r.logInfoEvent(owner, RsnSecretCreateSucc, MsgSecretCreateSucc, loggingKv...)
                        return ReconcileError{}</span>
                }
                // Return error
                <span class="cov0" title="0">return ReconcileError{
                        Reason:         RsnSecretGetFail,
                        Message:        MsgSecretGetFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }</span>
        } else<span class="cov1" title="1"> {
                // Create was called on already existing Secret
                return ReconcileError{
                        Reason:         RsnSecretExists,
                        Message:        MsgSecretExists,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
}

// createSecret creates a new K8s secret owned by owner with the data contained in output and dsn.
func (r *DatabaseReconciler) updateSecret(owner *databasev1.Database, secretFormat database.SecretFormat, output database.OpOutput) ReconcileError <span class="cov3" title="3">{
        logger.V(DebugLevel).Info("Updating secret for database resource")

        // TODO: extract common behavior of Secret rendering into a method and put it in createSecret as well (factory method)?
        // Init vars
        secretName := FormatSecretName(owner)
        loggingKv := StringsToInterfaceSlice("secret", secretName)
        secretData, err := secretFormat.RenderSecretFormat(output)
        if err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         RsnSecretRenderFail,
                        Message:        MsgSecretRenderFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="3">var ownerRefs []metav1.OwnerReference
        ownerRefs = append(ownerRefs, metav1.OwnerReference{
                APIVersion: owner.APIVersion,
                Kind:       owner.Kind,
                Name:       owner.Name,
                UID:        owner.UID,
                Controller: &amp;[]bool{true}[0], // sets this controller as owner
        })
        newSecret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            secretName,
                        Namespace:       owner.Namespace,
                        OwnerReferences: ownerRefs,
                },
                StringData: secretData,
        }
        if err := r.Client.Update(context.Background(), newSecret); err != nil </span><span class="cov0" title="0">{
                return ReconcileError{
                        Reason:         MsgSecretUpdateFail,
                        Message:        MsgSecretUpdateFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }
        }</span>
        <span class="cov3" title="3">r.logInfoEvent(owner, RsnSecretUpdateSucc, MsgSecretUpdateSucc, loggingKv...)
        return ReconcileError{}</span>
}

// updateReadyCondition updates the Ready Condition status of obj.
func (r *DatabaseReconciler) updateReadyCondition(obj *databasev1.Database, status metav1.ConditionStatus, reason, message string) error <span class="cov6" title="17">{
        meta.SetStatusCondition(&amp;obj.Status.Conditions, metav1.Condition{
                Type:    TypeReady,
                Status:  status,
                Reason:  reason,
                Message: message,
        })

        // Update condition field
        return r.Client.Status().Update(context.Background(), obj)
}</span>

// shouldRotate returns true if there isn't any Secret associated with the given Database object (secret deletion),
// or if the rotate annotation is present. It returns false otherwise, or if an error was generated during execution.
func (r *DatabaseReconciler) shouldRotate(obj *databasev1.Database) (bool, ReconcileError) <span class="cov6" title="14">{
        logger.V(TraceLevel).Info("Checking if credentials should be rotated")
        if isSecretPresent, err := r.isSecretPresent(obj); !isSecretPresent </span><span class="cov1" title="1">{
                if err.IsNotEmpty() </span><span class="cov0" title="0">{
                        return false, ReconcileError{
                                Reason:  RsnSecretGetFail,
                                Message: MsgSecretGetFail,
                                Err:     err.Err,
                        }
                }</span>
                <span class="cov1" title="1">return true, ReconcileError{}</span>
        }
        // secret is present, check if rotate annotation is present, if yes, rotate, else, just keep going
        <span class="cov6" title="13">if isRotateAnnotationTrue(obj) </span><span class="cov3" title="3">{
                return true, ReconcileError{}
        }</span>
        <span class="cov5" title="10">return false, ReconcileError{}</span>
}

// isSecretPresent returns true if the Secret bound to obj is present. It returns false otherwise, or if an
// error was generated during execution.
func (r *DatabaseReconciler) isSecretPresent(obj *databasev1.Database) (bool, ReconcileError) <span class="cov6" title="18">{
        secretName := FormatSecretName(obj)
        loggingKv := StringsToInterfaceSlice(SecretName, secretName)
        logger.V(TraceLevel).Info("Checking if secret bound to Database resource is present")

        var secret corev1.Secret
        secretObjKey := client.ObjectKey{Namespace: obj.Namespace, Name: FormatSecretName(obj)}
        if err := r.Client.Get(context.Background(), secretObjKey, &amp;secret); err != nil </span><span class="cov2" title="2">{
                if k8sError.IsNotFound(err) </span><span class="cov2" title="2">{
                        // Secret for given object is not present
                        return false, ReconcileError{}
                }</span>
                // Another error was generated while getting the Secret, return it
                <span class="cov0" title="0">return false, ReconcileError{
                        Reason:         RsnSecretGetFail,
                        Message:        MsgSecretGetFail,
                        Err:            err,
                        AdditionalInfo: loggingKv,
                }</span>
        }
        <span class="cov6" title="16">return true, ReconcileError{}</span>
}

// IsNotEmpty checks if r is not empty using reflect.DeepEqual. Needed because field AdditionalInfo is not comparable.
func (r ReconcileError) IsNotEmpty() bool <span class="cov10" title="79">{
        return !reflect.DeepEqual(r, ReconcileError{})
}</span>

// With creates a copy of the receiver and appends values to its AdditionalInfo field.
func (r ReconcileError) With(values []interface{}) ReconcileError <span class="cov1" title="1">{
        return ReconcileError{
                Reason:         r.Reason,
                Message:        r.Message,
                Err:            r.Err,
                AdditionalInfo: append(r.AdditionalInfo, values...),
        }
}</span>

// FormatSecretName returns the name of a Database's Secret resource as it should appear in metadata.name.
func FormatSecretName(obj *databasev1.Database) string <span class="cov9" title="63">{
        return obj.Name + "-credentials"
}</span>

// triggerReconciler checks whether reconciliation should be triggered or not to avoid useless reconciliations.
// See also predicate.Predicate.
func (r *DatabaseReconciler) triggerReconciler() predicate.Predicate <span class="cov1" title="1">{
        return predicate.Funcs{
                GenericFunc: func(e event.GenericEvent) bool </span><span class="cov0" title="0">{
                        obj := e.Object.(*databasev1.Database)
                        // If credentials are supposed to be rotated
                        if shouldRotate, err := r.shouldRotate(obj); shouldRotate || err.IsNotEmpty() </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        // If object is supposed to be deleted
                        <span class="cov0" title="0">if obj.GetDeletionTimestamp() != nil &amp;&amp; contains(e.Object.GetFinalizers(), databaseFinalizer) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        // If ready condition is false or unknown
                        <span class="cov0" title="0">if !meta.IsStatusConditionTrue(obj.Status.Conditions, TypeReady) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">return false</span>
                },
        }
}

// isRotateAnnotationTrue checks whether the rotate annotation is present and set to true or ""
func isRotateAnnotationTrue(obj client.Object) bool <span class="cov6" title="17">{
        if val, ok := obj.GetAnnotations()[rotateAnnotationKey]; ok &amp;&amp; val == "" || val == "true" </span><span class="cov4" title="6">{
                return true
        }</span>
        <span class="cov5" title="11">return false</span>
}

// newOpValuesFromResource constructs a database.OpValues struct starting from a Database resource.
func newOpValuesFromResource(obj *databasev1.Database) (database.OpValues, ReconcileError) <span class="cov6" title="13">{
        metaIn := obj.ObjectMeta
        var metadata map[string]interface{}
        temp, _ := json.Marshal(metaIn)
        err := json.Unmarshal(temp, &amp;metadata)
        if err != nil </span><span class="cov0" title="0">{
                return database.OpValues{}, ReconcileError{
                        Reason:  RsnDbMetaParseFail,
                        Message: MsgDbMetaParseFail,
                        Err:     err,
                }
        }</span>
        <span class="cov6" title="13">specIn := obj.Spec.Params
        var spec map[string]string
        temp, err = json.Marshal(specIn)
        err = json.Unmarshal(temp, &amp;spec)
        if err != nil </span><span class="cov0" title="0">{
                return database.OpValues{}, ReconcileError{
                        Reason:  RsnDbSpecParseFail,
                        Message: MsgDbSpecParseFail,
                        Err:     err,
                }
        }</span>

        <span class="cov6" title="13">return database.OpValues{
                Metadata:   metadata,
                Parameters: spec,
        }, ReconcileError{}</span>
}

// formatEventMessage formats an event message with key and values formatted as a json key-value structure. If keyAndValues
// is empty, it returns the message back.
func formatEventMessage(message string, keyAndValues ...interface{}) string <span class="cov8" title="31">{
        if len(keyAndValues) &gt; 0 </span><span class="cov5" title="9">{
                extraValues := formatKeyAndValuesAsJson(keyAndValues)
                if extraValues != "" </span><span class="cov5" title="9">{
                        return fmt.Sprintf("%s: %s", message, extraValues)
                }</span>
        }
        <span class="cov7" title="22">return message</span>
}

// formatKeyAndValuesAsJson converts a slice of interface{} into a json key-value string. Keys need to be strings by JSON's convention.
func formatKeyAndValuesAsJson(keyAndValues []interface{}) string <span class="cov5" title="9">{
        keyAndValuesLen := len(keyAndValues)
        if keyAndValuesLen%2 != 0 </span><span class="cov0" title="0">{
                logger.Error(fmt.Errorf("expected an even number of arguments, provided: %d", keyAndValuesLen),
                        "odd number of keyAndValues provided!", keyAndValues...)
                // Set length to 0 so additional values are ignored
                keyAndValuesLen = 0
        }</span>
        <span class="cov5" title="9">if keyAndValuesLen &gt; 0 </span><span class="cov5" title="9">{
                keyAndValuesMap := make(map[string]interface{}, keyAndValuesLen/2)
                for i := 0; i &lt; keyAndValuesLen; i += 2 </span><span class="cov6" title="12">{
                        key, ok := keyAndValues[i].(string)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error(fmt.Errorf("expected key at position %d to be string, provided: %T", i, keyAndValues[i]),
                                        "keys must be strings!", keyAndValues...)
                                // Set length to 0 so additional values are ignored
                                keyAndValuesLen = 0
                        }</span>
                        <span class="cov6" title="12">keyAndValuesMap[key] = keyAndValues[i+1]</span>
                }
                <span class="cov5" title="9">str, err := json.Marshal(keyAndValuesMap)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "cannot marshal keyAndValues to JSON")
                        return ""
                }</span>
                <span class="cov5" title="9">return string(str)</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// contains is a very small utility function which returns true if s has been found in list.
func contains(list []string, s string) bool <span class="cov6" title="12">{
        for _, v := range list </span><span class="cov5" title="8">{
                if v == s </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov3" title="4">return false</span>
}

// shouldIgnoreUpdateErr checks if an error message is generated due to the optimistic locking mechanism of Kubernetes API.
// This specific error is innocuous and should be generally ignored.
// See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func shouldIgnoreUpdateErr(err error) bool <span class="cov1" title="1">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">if strings.Contains(err.Error(), genericregistry.OptimisticLockErrorMsg) </span><span class="cov0" title="0">{
                // do manual retry without error
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "fmt"
        "text/template"
)

const (
        Sqlserver               = "sqlserver"
        Postgres                = "postgres"
        Mysql                   = "mysql"
        Mariadb                 = "mariadb"
        CreateMapKey            = "create"
        DeleteMapKey            = "delete"
        RotateMapKey            = "rotate"
        OperationsConfigKey     = "operations"
        ErrorOnMissingKeyOption = "missingkey=error"
        DbmsConfigKey           = "dbms"
)

// Driver represents a struct responsible for executing CreateDb and DeleteDb operations on a system it supports. Drivers
// should provide a way to check their current status (i.e. whether it can accept CreateDb and DeleteDb operations at the
// moment of a Ping call
type Driver interface {
        CreateDb(operation Operation) OpOutput
        DeleteDb(operation Operation) OpOutput
        Rotate(operation Operation) OpOutput
        Ping() error
}

// DbmsConn represents the DBMS connection. See Driver.
type DbmsConn struct {
        Driver
}

// +kubebuilder:object:generate=true
// Operation represents an operation performed on a DBMS identified by name and containing a map of inputs and a map
// of outputs.
type Operation struct {
        Name   string            `json:"name,omitempty"`
        Inputs map[string]string `json:"inputs,omitempty"`
}

// OpOutput represents the return values of an operation. If the operation generates an error, it must be set in the Err
// field. If Err is nil, the operation is assumed to be successful.
type OpOutput struct {
        Result map[string]string
        Err    error
}

// OpValues represent the input values of an operation.
type OpValues struct {
        Metadata   map[string]interface{}
        Parameters map[string]string
}

// +kubebuilder:object:generate=true
// Dbms is the instance associated with a Dbms resource. It contains the Driver responsible for the Operations executed on
// Endpoints.
type Dbms struct {
        DatabaseClassName string     `json:"databaseClassName"`
        Endpoints         []Endpoint `json:"endpoints"`
}

// SecretKeyRef specifies a reference to a value contained in a Secret resource identified by name and key.
type SecretKeyRef struct {
        Name string `json:"name"`
        Key  string `json:"key"`
}

// +kubebuilder:object:generate=true
// DbmsList is a slice containing Dbms structs.
type DbmsList []Dbms

// +kubebuilder:object:generate=true
// +kubebuilder:kubebuilder:validation:MinItems=1
// Endpoint represent the configuration of a DBMS endpoint identified by a name.
type Endpoint struct {
        Name         string       `json:"name"`
        SecretKeyRef SecretKeyRef `json:"secretKeyRef,omitempty"`
        Dsn          Dsn          `json:"dsn,omitempty"`
}

// +kubebuilder:object:generate=true
type SecretFormat map[string]string

// New initializes a Dbms instance based on a map of Operation. It expects a dsn like that:
// driver://username:password@host/instance?param1=value&amp;param2=value
//
// See the individual Driver implementations.
func New(driver string, dsn Dsn) (*DbmsConn, error) <span class="cov0" title="0">{
        var dbmsConn *DbmsConn

        switch driver </span>{
        case Sqlserver:<span class="cov0" title="0">
                parsedDsn, err := dsn.GenSqlserver()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, formatDsnParseError(err)
                }</span>
                <span class="cov0" title="0">sqlserverConn, err := NewSqlserverConn(parsedDsn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">dbmsConn = &amp;DbmsConn{sqlserverConn}</span>
        case Postgres:<span class="cov0" title="0">
                parsedDsn, err := dsn.GenPostgres()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, formatDsnParseError(err)
                }</span>
                <span class="cov0" title="0">psqlConn, err := NewPsqlConn(parsedDsn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">dbmsConn = &amp;DbmsConn{psqlConn}</span>
        case Mysql, Mariadb:<span class="cov0" title="0">
                parsedDsn, err := dsn.GenMysql()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, formatDsnParseError(err)
                }</span>
                <span class="cov0" title="0">mysqlConn, err := NewMysqlConn(parsedDsn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">dbmsConn = &amp;DbmsConn{mysqlConn}</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid dsn '%s': driver not found", dsn)</span>
        }

        <span class="cov0" title="0">if err := dbmsConn.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return dbmsConn, nil</span>
}

// RenderOperation renders "actions" specified through the use of the Go text/template format. It renders Input of
// the receiver. Data to be inserted is taken directly from values. See OpValues. If the rendering is successful, the
// method returns ah na rendered Operation, if an error is generated, it is returned along with an empty Operation struct.
// Keys which are specified but not found generate an error (i.e. no unreferenced keys are allowed).
func (op Operation) RenderOperation(values OpValues) (Operation, error) <span class="cov4" title="3">{
        // Transform map[string]string to a single json string
        operationTemplate, err := json.Marshal(op.Inputs)
        if err != nil </span><span class="cov0" title="0">{
                return Operation{}, err
        }</span>
        <span class="cov4" title="3">renderedInputsString, err := RenderGoTemplate(string(operationTemplate), values, ErrorOnMissingKeyOption)
        if err != nil </span><span class="cov1" title="1">{
                return Operation{}, err
        }</span>
        <span class="cov3" title="2">var renderedInputsMap map[string]string
        err = json.Unmarshal([]byte(renderedInputsString), &amp;renderedInputsMap)
        if err != nil </span><span class="cov0" title="0">{
                return Operation{}, err
        }</span>
        <span class="cov3" title="2">renderedOp := Operation{
                Name:   op.Name,
                Inputs: renderedInputsMap,
        }

        return renderedOp, nil</span>
}

// GetDatabaseClassNameByEndpointName performs a linear search on the receiver in search of endpointName. If an entry
// is found, it is returned.
func (c DbmsList) GetDatabaseClassNameByEndpointName(endpointName string) string <span class="cov0" title="0">{
        for _, dbms := range c </span><span class="cov0" title="0">{
                if contains(dbms.Endpoints, endpointName) </span><span class="cov0" title="0">{
                        return dbms.DatabaseClassName
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// IsNamePresent return true if an endpoint name is not empty, else it returns false.
func (e Endpoint) IsNamePresent() bool <span class="cov0" title="0">{
        return e.Name != ""
}</span>

// IsDsnPresent return true if an endpoint dsn is not empty, else it returns false.
func (e Endpoint) IsDsnPresent() bool <span class="cov0" title="0">{
        return e.Dsn != ""
}</span>

// RenderSecretFormat renders a secret from OpOutput.Result create operation.
func (s SecretFormat) RenderSecretFormat(createOpOutput OpOutput) (SecretFormat, error) <span class="cov4" title="3">{
        // Transform map[string]string to a single json string
        stringInputs, err := json.Marshal(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">renderedInputsString, err := RenderGoTemplate(string(stringInputs), createOpOutput, ErrorOnMissingKeyOption)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="2">var renderedInputsMap map[string]string
        err = json.Unmarshal([]byte(renderedInputsString), &amp;renderedInputsMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">renderedSecretFormat := SecretFormat(renderedInputsMap)

        return renderedSecretFormat, nil</span>
}

// RenderGoTemplate takes the text to be parsed as a Go template and values to be rendered. For options see template.Option.
func RenderGoTemplate(text string, values interface{}, options ...string) (string, error) <span class="cov6" title="6">{
        // Setup the template to be rendered based on the inputs
        tmpl, err := template.New("gotmpl").Parse(text)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="6">tmpl.Option(options...)
        // Create a new buffer for the rendering result
        renderedInputsBuf := bytes.NewBufferString("")
        // Render each templated value by taking the values from values
        err = tmpl.Execute(renderedInputsBuf, values)
        if err != nil </span><span class="cov3" title="2">{
                return "", err
        }</span>
        <span class="cov5" title="4">return renderedInputsBuf.String(), nil</span>
}

// contains is a very small utility function which returns true if s has been found in list.
func contains(list []Endpoint, s string) bool <span class="cov0" title="0">{
        for _, v := range list </span><span class="cov0" title="0">{
                if v.Name == s </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// getQueryInputs returns a slice of sql.Named(k, v) from values where k is the key and v is the value.
func getQueryInputs(values map[string]string) []interface{} <span class="cov10" title="15">{
        var inputParams []interface{}
        for k, v := range values </span><span class="cov10" title="15">{
                inputParams = append(inputParams, sql.Named(k, v))
        }</span>
        <span class="cov10" title="15">return inputParams</span>
}

func formatDsnParseError(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("error parsing dsn: %s", err)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import "github.com/xo/dburl"

type Dsn string

func (dsn Dsn) GenMysql() (string, error) <span class="cov1" title="1">{
        u, err := dburl.Parse(dsn.String())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">parsedDsn, err := dburl.GenMySQL(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return parsedDsn, nil</span>
}

func (dsn Dsn) GenSqlserver() (string, error) <span class="cov5" title="2">{
        u, err := dburl.Parse(dsn.String())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="2">parsedDsn, err := dburl.GenSQLServer(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov5" title="2">return parsedDsn, nil</span>
}

func (dsn Dsn) GenPostgres() (string, error) <span class="cov1" title="1">{
        u, err := dburl.Parse(dsn.String())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">parsedDsn, err := dburl.GenPostgres(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">return parsedDsn, nil</span>
}

// String returns a string from a Dsn.
func (dsn Dsn) String() string <span class="cov10" title="4">{
        return string(dsn)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "database/sql"
        "fmt"
        _ "github.com/go-sql-driver/mysql"
        "strconv"
)

// MysqlConn represents a connection to a MySQL DBMS.
type MysqlConn struct {
        c *sql.DB
}

// NewMysqlConn opens a new SQL Server connection from a given dsn.
func NewMysqlConn(dsn string) (*MysqlConn, error) <span class="cov1" title="1">{
        dbConn, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">conn := MysqlConn{dbConn}
        return &amp;conn, nil</span>
}

// CreateDb attempts to create a new database as specified in the operation parameter. It returns an OpOutput with the
// result of the call.
func (c *MysqlConn) CreateDb(operation Operation) OpOutput <span class="cov6" title="5">{
        sp, err := GetMysqlOpQuery(operation)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{
                        Result: nil,
                        Err:    err,
                }
        }</span>

        <span class="cov6" title="5">rows, err := c.c.Query(sp)
        if err != nil </span><span class="cov3" title="2">{
                return OpOutput{Result: nil, Err: err}
        }</span>

        <span class="cov4" title="3">var key string
        var value string
        result := make(map[string]string)
        for rows.Next() </span><span class="cov10" title="18">{
                err = rows.Scan(&amp;key, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return OpOutput{nil, err}
                }</span>
                <span class="cov10" title="18">result[key] = value</span>
        }

        <span class="cov4" title="3">return OpOutput{result, nil}</span>
}

// DeleteDb attempts to delete a database instance as specified in the operation parameter. It returns an OpOutput with the
// result of the call if present.
func (c *MysqlConn) DeleteDb(operation Operation) OpOutput <span class="cov0" title="0">{
        sp, err := GetMysqlOpQuery(operation)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{
                        Result: nil,
                        Err:    err,
                }
        }</span>
        <span class="cov0" title="0">_, err = c.c.Exec(sp)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{nil, err}
        }</span>

        <span class="cov0" title="0">return OpOutput{}</span>
}

// Rotate attempts to rotate the credentials of a connection.
func (c *MysqlConn) Rotate(operation Operation) OpOutput <span class="cov0" title="0">{
        sp, err := GetMysqlOpQuery(operation)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{
                        Result: nil,
                        Err:    err,
                }
        }</span>

        <span class="cov0" title="0">rows, err := c.c.Query(sp)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{Result: nil, Err: err}
        }</span>

        <span class="cov0" title="0">var key string
        var value string
        result := make(map[string]string)
        for rows.Next() </span><span class="cov0" title="0">{
                err = rows.Scan(&amp;key, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return OpOutput{nil, err}
                }</span>
                <span class="cov0" title="0">result[key] = value</span>
        }

        <span class="cov0" title="0">return OpOutput{result, nil}</span>
}

// Ping returns an error if a connection cannot be established with the DBMS, else it returns nil.
func (c *MysqlConn) Ping() error <span class="cov0" title="0">{
        return c.c.Ping()
}</span>

// GetMysqlOpQuery constructs a CALL query from the specified operation. Keys of operation.Inputs must be integers, they
// are converted from string to int and then used to sort the parameters in the stored procedure call. If keys are not
// specified as integers, an error is returned.
func GetMysqlOpQuery(operation Operation) (string, error) <span class="cov6" title="6">{
        inputs, err := getMysqlInputs(operation.Inputs)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov6" title="6">return fmt.Sprintf("CALL %s(%s)", operation.Name, inputs), nil</span>
}

func getMysqlInputs(inputs map[string]string) (string, error) <span class="cov6" title="6">{
        if len(inputs) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov6" title="6">sortedParams := make([]string, len(inputs))
        // Store the values in slice in sorted order
        for k, v := range inputs </span><span class="cov8" title="10">{
                numKey, err := strconv.Atoi(k)
                if err != nil </span><span class="cov1" title="1">{
                        if err == strconv.ErrSyntax </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("key of input '%s' should be an int: %s", k, err)
                        }</span>
                        <span class="cov1" title="1">return "", nil</span>
                }
                <span class="cov7" title="9">sortedParams[numKey] = v</span>
        }

        <span class="cov6" title="5">var result string
        for _, param := range sortedParams </span><span class="cov7" title="9">{
                result = fmt.Sprintf("%s, '%s'", result, param)
        }</span>
        <span class="cov6" title="5">result = result[2:]

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package database

import (
        "context"
        "fmt"
        "github.com/jackc/pgx/v4/pgxpool"
)

// PsqlConn represents a connection to a SQL Server DBMS.
type PsqlConn struct {
        c *pgxpool.Pool
}

// NewPsqlConn opens a new PostgreSQL connection from a given dsn.
func NewPsqlConn(dsn string) (*PsqlConn, error) <span class="cov1" title="1">{
        dbConn, err := pgxpool.Connect(context.Background(), dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">conn := PsqlConn{dbConn}

        return &amp;conn, nil</span>
}

// CreateDb attempts to create a new database as specified in the operation parameter. It returns an OpOutput with the
// result of the call.
func (c *PsqlConn) CreateDb(operation Operation) OpOutput <span class="cov4" title="2">{
        val := getPsqlOpQuery(operation)
        rows, err := c.c.Query(context.Background(), val)
        if err != nil </span><span class="cov1" title="1">{
                return OpOutput{Result: nil, Err: err}
        }</span>

        <span class="cov1" title="1">var key string
        var value string
        result := make(map[string]string)
        for rows.Next() </span><span class="cov10" title="6">{
                err = rows.Scan(&amp;key, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return OpOutput{nil, err}
                }</span>
                <span class="cov10" title="6">result[key] = value</span>
        }

        <span class="cov1" title="1">return OpOutput{result, nil}</span>
}

// DeleteDb attempts to delete a database instance as specified in the operation parameter. It returns an OpOutput with the
// result of the call if present.
func (c *PsqlConn) DeleteDb(operation Operation) OpOutput <span class="cov0" title="0">{
        _, err := c.c.Exec(context.Background(), getPsqlVoidOpQuery(operation))
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{nil, err}
        }</span>

        <span class="cov0" title="0">return OpOutput{}</span>
}

// Rotate attempts to rotate the credentials of a connection.
func (c *PsqlConn) Rotate(operation Operation) OpOutput <span class="cov0" title="0">{
        val := getPsqlOpQuery(operation)
        rows, err := c.c.Query(context.Background(), val)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{nil, err}
        }</span>

        <span class="cov0" title="0">var key string
        var value string
        result := make(map[string]string)
        for rows.Next() </span><span class="cov0" title="0">{
                err = rows.Scan(&amp;key, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return OpOutput{nil, err}
                }</span>
                <span class="cov0" title="0">result[key] = value</span>
        }

        <span class="cov0" title="0">return OpOutput{result, nil}</span>
}

// Ping returns an error if a connection cannot be established with the DBMS, else it returns nil.
func (c *PsqlConn) Ping() error <span class="cov0" title="0">{
        return c.c.Ping(context.Background())
}</span>

func getPsqlOpQuery(operation Operation) string <span class="cov4" title="2">{
        return fmt.Sprintf("select * from %s(%s)", operation.Name, getPsqlInputs(operation.Inputs))
}</span>

func getPsqlVoidOpQuery(operation Operation) string <span class="cov0" title="0">{
        return fmt.Sprintf("select %s(%s)", operation.Name, getPsqlInputs(operation.Inputs))
}</span>

func getPsqlInputs(values map[string]string) string <span class="cov4" title="2">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="2">var result string
        for k, v := range values </span><span class="cov4" title="2">{
                result = fmt.Sprintf("%s := '%s', %s", k, v, result) // params specified on reverse order on purpose as a sanity check for postgres
        }</span>

        <span class="cov4" title="2">result = result[:len(result)-2]
        return result</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "fmt"
        "go.uber.org/ratelimit"
)

type RateLimitedDbmsConn struct {
        Driver
        limiter ratelimit.Limiter
}

// NewRateLimitedDbmsConn returns a new rate-limited dbms connection. Rps specifies the number of allowed requests per
// second for this dbms connection. If rps is equal to 0, it returns a connection that is not rate-limited.
// Rps cannot be a negative number.
func NewRateLimitedDbmsConn(dbmsConn Driver, rps int) (*RateLimitedDbmsConn, error) <span class="cov1" title="1">{
        if rps &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rps cannot be a negative number. Rps found: %d", rps)
        }</span>
        <span class="cov1" title="1">var limiter ratelimit.Limiter
        if rps == 0 </span><span class="cov0" title="0">{
                limiter = ratelimit.NewUnlimited()
        }</span> else<span class="cov1" title="1"> {
                limiter = ratelimit.New(rps)
        }</span>

        <span class="cov1" title="1">return &amp;RateLimitedDbmsConn{
                Driver:  dbmsConn,
                limiter: limiter,
        }, nil</span>
}

func (conn *RateLimitedDbmsConn) CreateDb(operation Operation) OpOutput <span class="cov10" title="10">{
        conn.limiter.Take()
        return conn.Driver.CreateDb(operation)
}</span>

func (conn *RateLimitedDbmsConn) DeleteDb(operation Operation) OpOutput <span class="cov0" title="0">{
        conn.limiter.Take()
        return conn.Driver.DeleteDb(operation)
}</span>

func (conn *RateLimitedDbmsConn) Ping() error <span class="cov0" title="0">{
        conn.limiter.Take()
        return conn.Driver.Ping()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "database/sql"
        _ "github.com/denisenkom/go-mssqldb"
)

// SqlserverConn represents a connection to a SQL Server DBMS.
type SqlserverConn struct {
        c *sql.DB
}

// NewSqlserverConn opens a new SQL Server connection from a given dsn.
func NewSqlserverConn(dsn string) (*SqlserverConn, error) <span class="cov2" title="2">{
        dbConn, err := sql.Open("sqlserver", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">conn := SqlserverConn{dbConn}
        return &amp;conn, nil</span>
}

// CreateDb attempts to create a new database as specified in the operation parameter. It returns an OpOutput with the
// result of the call.
func (c *SqlserverConn) CreateDb(operation Operation) OpOutput <span class="cov6" title="15">{
        inputParams := getQueryInputs(operation.Inputs)

        rows, err := c.c.Query(operation.Name, inputParams...)
        if err != nil </span><span class="cov2" title="2">{
                return OpOutput{Result: nil, Err: err}
        }</span>

        <span class="cov6" title="13">var key string
        var value string
        result := make(map[string]string)
        for rows.Next() </span><span class="cov10" title="78">{
                err = rows.Scan(&amp;key, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return OpOutput{nil, err}
                }</span>
                <span class="cov10" title="78">result[key] = value</span>
        }

        <span class="cov6" title="13">return OpOutput{result, nil}</span>
}

// DeleteDb attempts to delete a database instance as specified in the operation parameter. It returns an OpOutput with the
// result of the call.
func (c *SqlserverConn) DeleteDb(operation Operation) OpOutput <span class="cov0" title="0">{
        inputParams := getQueryInputs(operation.Inputs)

        _, err := c.c.Exec(operation.Name, inputParams...)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{nil, err}
        }</span>

        <span class="cov0" title="0">return OpOutput{}</span>
}

// Rotate attempts to rotate the credentials of a connection.
func (c *SqlserverConn) Rotate(operation Operation) OpOutput <span class="cov0" title="0">{
        inputParams := getQueryInputs(operation.Inputs)

        rows, err := c.c.Query(operation.Name, inputParams...)
        if err != nil </span><span class="cov0" title="0">{
                return OpOutput{Result: nil, Err: err}
        }</span>

        <span class="cov0" title="0">var key string
        var value string
        result := make(map[string]string)
        for rows.Next() </span><span class="cov0" title="0">{
                err = rows.Scan(&amp;key, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return OpOutput{nil, err}
                }</span>
                <span class="cov0" title="0">result[key] = value</span>
        }

        <span class="cov0" title="0">return OpOutput{result, nil}</span>
}

func (c *SqlserverConn) Ping() error <span class="cov0" title="0">{
        return c.c.Ping()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// +build !ignore_autogenerated

/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package database

import ()

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Dbms) DeepCopyInto(out *Dbms) <span class="cov0" title="0">{
        *out = *in
        if in.Endpoints != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Endpoints, &amp;out.Endpoints
                *out = make([]Endpoint, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Dbms.
func (in *Dbms) DeepCopy() *Dbms <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Dbms)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in DbmsList) DeepCopyInto(out *DbmsList) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(DbmsList, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DbmsList.
func (in DbmsList) DeepCopy() DbmsList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DbmsList)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Endpoint) DeepCopyInto(out *Endpoint) <span class="cov0" title="0">{
        *out = *in
        out.SecretKeyRef = in.SecretKeyRef
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Endpoint.
func (in *Endpoint) DeepCopy() *Endpoint <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Endpoint)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Operation) DeepCopyInto(out *Operation) <span class="cov0" title="0">{
        *out = *in
        if in.Inputs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Inputs, &amp;out.Inputs
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Operation.
func (in *Operation) DeepCopy() *Operation <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Operation)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in SecretFormat) DeepCopyInto(out *SecretFormat) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(SecretFormat, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretFormat.
func (in SecretFormat) DeepCopy() SecretFormat <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecretFormat)
        in.DeepCopyInto(out)
        return *out</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// This package opens and retains a pool of distinct DBMS connections.
package pool

import (
        "fmt"
        "github.com/bedag/kubernetes-dbaas/pkg/database"
        "github.com/go-logr/logr"
        "time"
)

// Pool specifies the generic interface for a Pool of DBMS connections.
type Pool interface {
        Get(name string) Entry
        Register(name string, driver string, dsn database.Dsn) error
        Keepalive(interval time.Duration, logger logr.Logger)
}

// Entry specifies the generic interface for an entry of DbmsPool.
type Entry interface {
        database.Driver
}

// DbmsPool is a map of pool entries identified by a unique name.
type DbmsPool struct {
        entries map[string]Entry
        rps     int
}

// Get retrieves an Entry from pool.
func (pool DbmsPool) Get(name string) Entry <span class="cov1" title="1">{
        return pool.entries[name]
}</span>

// DbmsEntry represents a standard Dbms connection.
type DbmsEntry struct {
        Entry
        driver string
        dsn    database.Dsn
}

// NewDbmsPool initializes a DbmsPool struct with the given rps. See also database.RateLimitedDbmsConn.
func NewDbmsPool(rps int) DbmsPool <span class="cov9" title="5">{
        return DbmsPool{
                entries: make(map[string]Entry),
                rps:     rps,
        }
}</span>

// RegisterDbms is a utility function around Register. It iterates over database.Dbms.Endpoints and registers a connection for
// each endpoint.
func (pool DbmsPool) RegisterDbms(dbms database.Dbms, driver string) error <span class="cov9" title="5">{
        for _, endpoint := range dbms.Endpoints </span><span class="cov10" title="6">{
                if err := pool.Register(endpoint.Name, driver, endpoint.Dsn); err != nil </span><span class="cov6" title="3">{
                        return err
                }</span>
        }
        <span class="cov4" title="2">return nil</span>
}

// Register registers a new database.Dbms in the pool.
func (pool DbmsPool) Register(name string, driver string, dsn database.Dsn) error <span class="cov10" title="6">{
        conn, err := database.New(driver, dsn)
        if err != nil </span><span class="cov4" title="2">{
                return fmt.Errorf("problem opening connection to endpoint with driver: '%s': %s", driver, err)
        }</span>
        <span class="cov7" title="4">rateLimitedConn, err := database.NewRateLimitedDbmsConn(conn, pool.rps)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="4">if _, exists := pool.entries[name]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("%s is already present in the pool. Endpoint names must be unique within the list "+
                        "of endpoints", name)
        }</span>
        <span class="cov6" title="3">pool.entries[name] = DbmsEntry{rateLimitedConn, driver, dsn}
        return err</span>
}

// Keepalive starts a periodic ping to each endpoint, if an endpoint becomes unreachable, an error is logged.
func (pool DbmsPool) Keepalive(interval time.Duration, logger logr.Logger) <span class="cov0" title="0">{
        logger = logger.WithName("pool")
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        for k, v := range pool.entries </span><span class="cov0" title="0">{
                                if err := v.Ping(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err, "connection to the endpoint failed", "endpoint", k)
                                }</span>
                        }
                        <span class="cov0" title="0">time.Sleep(interval)</span>
                }
        }()
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
